# Redis 产生背景

#### 1.1.数据存储的发展史

##### 1.1.1.磁盘时代

  很久之前，我们的数据存储方式是磁盘存储，每个磁盘都有一个磁道。每个磁道有很多扇区，一个扇区接近512Byte。

  **磁盘**的寻址速度是毫秒级的，带宽是GB/M的。**内存**是ns级的，带宽也比磁盘大上好几个数量级。总体来说，磁盘比内存在寻址上慢了接近10-100W倍。就带宽来讲，内存也比磁盘快很多，内存直接跟CPU的前端（数据）总线相连。

  在这段历史中，我们的面临的问题是，I/O问题。在读写文件时，我们常常面临很大的I/O成本问题。但是最初有个最初的解决方案是加一个buffer。

```
科普：什么是buffer？
  buffer是指一个缓冲区，我们在缓冲区来进行一个暂时的存放，之后统一运输给内存，这样会使得I/O的性能有略微提升。
```

##### 1.1.2.数据库的产生

  任何技术都不会平白无故产生。

  我们数据库技术就是由于磁盘的I/O瓶颈。为了解决这个问题，我们将磁盘扇区分为4K的一个个小的分区，构成索引。有了这些索引值，我们能通过索引，进行更加便捷的查找。索引也是使用的4k的存储模型，所不同的是它存储的是真是数据的位置，在哪个4k里存了
真是的数据。比如身份证表，每个身份证号指向了真是数据的data page。数据变多的时候，索引也会很多。为了我们能够更快的查找，对于关系型数据库表，必须给出schema就是每一列的类型、数据宽度，给出数据类型之后，每行数据的宽度就定死了，未来向表中
插入一行，假设一行有10个字段，我们只给出了第一个和第七个，往data page里面放的时候没有值的字段会用0填充，好处是：存的时候更倾向于行级存储，未来再设置为设置的字段的时候直接在0上面写就行了，不用移动数据。数据和索引都放在硬盘中。查的时候在
内存里准备一个B+树，B+树所有的叶子就是存储索引的那些4k小格子。
B+树的树干(区间和偏移)是在内存里的，只要是select语句中的where条件命中索引了，B+树会走树干，最后找到某个叶子，把叶子从磁盘读到内存，再把对应的data page读进内存来就可以找到记录了。内存中像二叉树一样的搜索索引。这样B+树和磁盘的安排可以发挥各自
的优势，获取数据时的IO减小。面试题：数据库表变得很大的时候，效率变低的原因是什么？如果表有索引，增删改会变慢，因为操作真实数据的时候也要修改其索引调整位置、维护索引；但是查询速度：1.假设内存和硬盘都存得下，来了一个或少量查询且命中索引，则依然很快
2. 并发或者复杂的SQL过来了的时候会受到硬盘带宽的限制：10000个查询散布在很多不同的4k上，各个4K挨个排队，这样会造成拥塞。寻址和带宽都会限制查询速度。 总之，数据库变大的时候，增删改查都会变慢。硬盘中的每个格子的大小是4k还是多大，取决于业务对于硬盘IO的
使用量：是更多的读他，IO密集型的，还是很多小文件。。。

```
科普：B+树是什么？
  我们普通的1-0树，又称二叉查找树（二叉排序树），二叉查找树和排序树是同一种树，就是单纯的1-0树，按照中序遍历的存储方式进行从小到大（从大到小）进行存储。（初学者可能误以为两种树，包括我刚开始学习数据结构的时候）。
  二叉查找树（二叉排序树）由于在插入和删除的时候，容易出现不太ok的情况，例如，可能在删除过程中删除为一个链表，这样查找效率依旧会变得很低。所以，我们使用旋转，通过左右旋转，将这种“链表”式（极端情况下）的树转化为左右平衡的树，这就是所谓的B-树。（注意误区，B树和B-树是一个树么？初学者认为后面一种是B减树，实际不是，是翻译过来的时候加的分隔符。B为Balance平衡的意思）
  当然，我们的数据库文件不是二叉的，文件系统也不是，所以，我们多叉的查找树，就是所谓的B+树。+号代表每个节点不止二叉的意思。
  
  （用自己的话粗略总结，详细还是看B-tree，B+tree的定义）
```

  在我们数据库的查找中，我们遇到一个问题？那就是字节宽度问题。我们建库的时候必须给出schema，我们行级存储，即使是该列为空，依旧要占位，那么，数据量庞大的时候，将会浪费很大的存储空间。但是这样的好处是，我们可以在update的时候不需要移动数据的位置。

##### 1.1.3.key-value数据库的产生



  任何技术都不会平白无故产生。

   我们将数据库发展到极致，产生出类似SAP公司的HANA数据库，是个内存级别的关系型数据库。这种数据库，硬件需求大，内存约2T，硬件+ERP软件+服务总和约2亿一个套餐。有一个问题是数据在磁盘和内存中的体积不一样，因为索引也是要占用磁盘空间的
磁盘里没有“指针”这个概念，磁盘里的数据会“胀出”，而且可以启动一些压缩和优化的策略。这是个数据库的极端，而一般的公司用不起，所以有了硬盘存数据+内存缓存的策略，把一些数据放到缓存，其中的技术有memcached、Redis.架构师必须要有技术选型
的能力：https://db-engines.com/en 架构师可以把一家公司带到上市或者破产。Redis是KV内存存储的 No1: https://db-engines.com/en/ranking/key-value+store 年薪20-30w必须懂Redis，简历上要有。技术选型或者跟项目组同事讨论的
时候，拿着https://db-engines.com/en/system/Redis和https://db-engines.com/en/system/MySQL之类的输出就可以了。Redis每秒1.5M此操作，latency小于1ms。关系型数据库也就是每秒几千   

Redis vs memcached  
```
Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets 
with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of 
on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.
```   
其中strings, hashes, lists, sets等五大类型指的都是value的类型。对比memcached，后者的value没有类型的概念，用Json表示是复杂的数据结构。世界上有3种数据表示：1. k=a,k=1 2. k=[1,2,3] k=[a,x,f] 3. k={x=y} k=[{},{}].
value有没有类型好像无所谓，而value类型的意义是：如果客户端想通过一个kv缓存系统取回value中的某一个元素，去的时候由于数据宽度一定，就好找数据了，memcached需要返回value所有数据到client端，这样如果很多请求的话网卡IO会成为瓶颈，
而且client这边要有客户自己实现的代码来解码json；换成redis的话，类型其实不重要，**重要的是Redis Server中对每种类型都有自己的方法**，如lpop()等，这样不用返回所有数据，Redis Server的网卡承受得了，而且客户端的代码也比较轻盈。
本质是解耦。借用大数据的词来说就是“**计算向数据移动**”，Memcached的JSON的解析过程是在client端。 

   随着互联网的发展，我们面临了一个新的问题。如何才能抵挡高并发，以及大数据导致的查找变慢呢？（注意，数据量变大，仅仅影响多数据查找，单数据查找并不会影响性能。我们的业务逻辑，通常是多条数据查找，所以才会有瓶颈）

   于是我们的k-v数据库产生了，这依赖于两个基础设施。冯诺依曼体系的硬件，以太网，和tcp/ip网络（不稳定，数据一致、双写等问题）。**参考附件：冯诺依曼体系图**

```
科普：什么是冯诺依曼体系？
  我们的操作系统老师是个年纪很大的教授，这边引用他的上课原话。
  冯诺依曼体系，至今没有一个明确的定义。有的书说有5个，有的书说有7个，但是，我依照某年考研题，来规范一下冯诺依曼体系。
  冯诺依曼体系由五部分组成，控制器，运算器，内存，总线，硬盘和I/O接口6部分组成。
  
  （如何记忆冯诺依曼体系构成：CPU分为控制器运算器，其他都为CPU服务，运算需要内存，连接需要总线，我们要读写必须要I/O接口。一切以CPU考虑，就能记全6个）
  
  参考附件：冯诺依曼体系图
  
```
Notion链接：https://www.notion.so/Redis-311b068fdb724ed8aa9706006e9efcfa

